import 'dart:convert' show jsonDecode;

/// Dependency type detected from static analysis
enum DependencyType {
  /// ref.watch() - Creates a reactive dependency
  watch,

  /// ref.read() - One-time read without subscription
  read,

  /// ref.listen() - Side-effect listener
  listen,
}

/// Information about a single dependency extracted from static analysis
class StaticDependency {
  /// Name of the provider this provider depends on
  final String providerName;

  /// Type of dependency (watch/read/listen)
  final DependencyType type;

  /// Source file path (relative to package root)
  final String file;

  /// Line number where the dependency is defined
  final int line;

  /// Column number where the dependency is defined
  final int column;

  const StaticDependency({
    required this.providerName,
    required this.type,
    required this.file,
    required this.line,
    required this.column,
  });

  /// Convert to JSON format for sending to DevTools
  Map<String, dynamic> toJson() => {
        'providerName': providerName,
        'type': type.name,
        'file': file,
        'line': line,
        'column': column,
      };

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is StaticDependency &&
          runtimeType == other.runtimeType &&
          providerName == other.providerName &&
          type == other.type &&
          file == other.file &&
          line == other.line &&
          column == other.column;

  @override
  int get hashCode =>
      providerName.hashCode ^
      type.hashCode ^
      file.hashCode ^
      line.hashCode ^
      column.hashCode;

  @override
  String toString() =>
      'StaticDependency($providerName, ${type.name}, $file:$line:$column)';
}

/// Metadata for a provider extracted from static analysis
class StaticProviderMetadata {
  /// Name of the provider
  final String name;

  /// List of dependencies this provider has
  final List<StaticDependency> dependencies;

  const StaticProviderMetadata({
    required this.name,
    required this.dependencies,
  });

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is StaticProviderMetadata &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          _listEquals(dependencies, other.dependencies);

  @override
  int get hashCode => name.hashCode ^ dependencies.hashCode;

  @override
  String toString() => 'StaticProviderMetadata($name, ${dependencies.length} dependencies)';

  bool _listEquals<T>(List<T> a, List<T> b) {
    if (a.length != b.length) return false;
    for (var i = 0; i < a.length; i++) {
      if (a[i] != b[i]) return false;
    }
    return true;
  }
}

/// Global registry for statically-analyzed provider dependencies
///
/// This registry can be populated in two ways:
/// 1. By loading from a JSON file generated by the CLI tool (recommended)
/// 2. By code-generated registration functions from build_runner (legacy)
///
/// The registry is queried by RiverpodDevToolsObserver to provide accurate
/// dependency information.
class RiverpodDevToolsRegistry {
  RiverpodDevToolsRegistry._();

  /// Singleton instance
  static final instance = RiverpodDevToolsRegistry._();

  /// Internal storage of provider metadata
  final Map<String, StaticProviderMetadata> _metadata = {};

  /// Register metadata for a provider
  ///
  /// This is typically called by generated code, not by user code.
  void register(StaticProviderMetadata metadata) {
    _metadata[metadata.name] = metadata;
  }

  /// Get full metadata for a provider
  ///
  /// Returns null if no static metadata is available for this provider.
  StaticProviderMetadata? getMetadata(String providerName) {
    return _metadata[providerName];
  }

  /// Get just the dependency names for a provider
  ///
  /// Returns an empty list if no static metadata is available.
  List<String> getDependencyNames(String providerName) {
    return _metadata[providerName]?.dependencies.map((dep) => dep.providerName).toList() ?? [];
  }

  /// Get dependencies with full details (type, source location) as JSON
  ///
  /// This is useful for sending detailed information to DevTools.
  List<Map<String, dynamic>> getDependenciesWithDetails(String providerName) {
    return _metadata[providerName]?.dependencies.map((dep) => dep.toJson()).toList() ?? [];
  }

  /// Check if a provider has static metadata
  bool hasMetadata(String providerName) {
    return _metadata.containsKey(providerName);
  }

  /// Get all registered provider names
  List<String> get allProviderNames => _metadata.keys.toList();

  /// Clear all registered metadata
  ///
  /// Primarily used for testing.
  void clear() {
    _metadata.clear();
  }

  /// Get the total number of registered providers
  int get count => _metadata.length;

  /// Load metadata from JSON string
  ///
  /// This is used by the CLI tool approach. The JSON format should match
  /// the output from `dart run riverpod_devtools:analyze`.
  ///
  /// Example:
  /// ```dart
  /// void main() async {
  ///   final jsonString = await rootBundle.loadString(
  ///     'lib/riverpod_dependencies.json'
  ///   );
  ///   RiverpodDevToolsRegistry.instance.loadFromJson(jsonString);
  ///
  ///   runApp(...);
  /// }
  /// ```
  void loadFromJson(String jsonString) {
    try {
      final Map<String, dynamic> json = jsonDecode(jsonString) as Map<String, dynamic>;
      final providers = json['providers'] as List<dynamic>?;

      if (providers != null) {
        for (final providerJson in providers) {
          final providerMap = providerJson as Map<String, dynamic>;
          final name = providerMap['name'] as String;
          final dependencies = (providerMap['dependencies'] as List<dynamic>)
              .map((depJson) => _parseDependency(depJson as Map<String, dynamic>))
              .toList();

          register(StaticProviderMetadata(
            name: name,
            dependencies: dependencies,
          ));
        }
      }
    } catch (e) {
      // Silently fail to not break app startup
      // In production, users can check the log for issues
      // ignore: avoid_print
      print('Warning: Failed to load riverpod dependencies from JSON: $e');
    }
  }

  StaticDependency _parseDependency(Map<String, dynamic> json) {
    final location = json['location'] as Map<String, dynamic>;
    return StaticDependency(
      providerName: json['providerName'] as String,
      type: DependencyType.values.firstWhere(
        (e) => e.name == json['type'],
      ),
      file: location['file'] as String,
      line: location['line'] as int,
      column: location['column'] as int,
    );
  }
}
